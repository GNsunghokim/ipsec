#include "ipsec.h"

int main(void)
{
	setting();
	
	IP* ip = (IP*)malloc(OUT_PACKET_LEN + 100);
	memset(ip, 0x0, OUT_PACKET_LEN);
	memcpy(ip, out_ip, OUT_PACKET_LEN); 

	outbound(ip);
	inbound(ip);
}

void setting()
{
	SP* sp_header_node = (SP*)malloc(sizeof(SP));
	SA* sa_header_node = (SA*)malloc(sizeof(SA));

	SP* sp_node1 = &sp;
	SP* sp_node2 = &sp2;

	SA* sa_node1 = &sa;
	SA* sa_node2 = &sa2; 

	sp->sa_pointer = &sa;
	sp2->sa_pointer = &sa2;
	sa->sp_pointer = &sp;
	sa2->sp_pointer = &sp2;
	
	spd.sp_list = sp_header_node;
	sad.sa_list = sa_header_node;

	INIT_LIST_HEAD(&((spd.sp_list)->list));
	INIT_LIST_HEAD(&((sad.sa_list)->list));

	list_add(sp_node1, &((spd.sp_list)->list));
	list_add(sp_node2, &((spd.sp_list)->list));
	list_add(sa_node1, &((sad.sa_list)->list));
	list_add(sa_node2, &((sad.sa_list)->list));

}

int decrypt(IP* packet)
{
	int size; 
	current_sa = NULL;
	current_sp = NULL;

	// 1. SAD Lookup
	if(current_sa = sad->get(packet) == NULL)
	{
		printf(" 1. SAD Lookup : Discard packet \n");
	
		return -1;
	}

	if(sad->check(current_sa, packet) != true)
	{
		printf(" SAD Check : Discard packet\n");
		
		return -1;
	}
	// TODO : ICMP processing
	current_sp = current_sa->sp_pointer;

	// 2. SPD Lookup 
	spd->check(current_sp, packet);

	current_sa->crypto = get_cryptography(current_sa->crypto_name);
	current_sa->auth = get_authentication(current_sa->auth_name);

	// Branch by mode
	switch(current_sp->mode)
	{
		 case TRANSPORT : 
			// Branch by IPSec protocol
			switch(current_sp->ipsec_proto)
			{
				case IP_PROTOCOL_ESP :
					// 2. Seq# Validation
					if(current_sa->window->checkWindow(esp->seq_num) < 0)
					{
						printf(" 2. Seq# Validation : Discard Packet \n");

						return -1;
					}
					
					// 3. ICV Validation
					if(current_sa->iv_mode == true)
					{
						size = endian16(packet->length) - (packet->ihl * 4) - ICV_LEN; 
						unsigned char* result;
						
						current_sa->auth->authenticate(packet, size, result);
					
						if(memcmp(result, &(packet->body[size], 12) != 0)
						{
							printf(" 3. ICV Validation : Discard Packet \n");

							return -1;
						}
					}
	
					// 4. Decrypt
					size = endian16(packet->length) - (packet->ihl * 4) - ESP_HEADER_LEN; 
					
					ESP* esp = (ESP*)packet->body;
					current_sa->crypto->decrypt(esp, size); 
					
					// 5. ESP Header & Trailer Deletion
					size = endian16(packet->length) - (packet->ihl * 4) - ESP_HEADER_LEN;
					if(current_sa->iv_mode == true)
						size -= ICV_LEN;

					packet->protocol = esp->body[len - 1];
					memmove(packet->body, esp->body, len);

					break;
				
				case IP_PROTOCOL_AH : 	
					break;
				default : break;
			}
			break;
		case TUNNEL :
			switch(current_sp->ipsec_proto)
			{
				case IP_PROTOCOL_ESP:
					ESP* esp = (ESP*)packet->body;
					// 2. Seq# Validation
					// 3. ICV Validation
					current_sa->auth->authenticate(packet, packet_len);
					// 4. Decrypt
					current_sa->crypto->cryptograph(packet, packet_len);
					// 5. Outer IP & ESP Header & Trailer Deletion
					break;
				case IP_PROTOCOL_AH:
					break;
				default : break;
			}
			break;
		default : break;
	}	
	
	return 0;
}

int outbound(IP* packet)
{
	int size;
	current_sp = NULL;
	current_sa = NULL;

	// 1. SPD Lookup
	if(current_sp = spd->get(packet) == NULL)
	{
		printf(" 1. SPD Lookup : Bypass packet\n");
		
		return 1;
	}
	
	// 2. SAD Lookup
	current_sa = current_sp->sa_pointer;
	if(sad->check(current_sa, packet) != true)
	{
		printf("SAD check : Discard packet\n");
		
		return -1;
	}

	current_sa->crypto = get_cryptography(current_sa->crypto_name);
	current_sa->auth = get_authentication(current_sa->auth_name);

	// Branch by IPSec Protocol
	switch(current_sp->mode)
	{
		case TRANSPORT :
			switch(current_sp->protocol)
			{
				case IP_PROTOCOL_ESP :
					// 3. Encrypt
					int body_len = endian16(packet->length) - (packet->ihl * 4); 
					int padding_len = 8 - (body_len + 2) % 8;
					unsigned char* padding = packet->body + body_len;
					
					for(int i = 0; i < padding_len; i++)
						padding[i] = i + 1;
					
					packet->body[body_len + padding_len + 1] = packet->protocol;
					packet->body[body_len + padding_len] = padding_len;

					size = body_len + padding_len + 2;

					current_sa->crypto->encrypt(packet->body, size);		

					// 4. ESP Header & Trailer Addition
					packet->protocol = IP_PROTOCOL_ESP
					packet->length = endian16(endian16(packet->length) + ESP_HEADER_LEN + 2 + padding_len);
					if(current_sa->iv_mode == true)
						packet->length += endian16(ICV_LEN);

					memmove(packet->body + ESP_HEADER_LEN, packet->body, endian16(packet->length));
					
					ESP* esp = (ESP*)packet->body;
					esp->spi = endian32(current_sa->spi);
					
					// 5. Seq# Validation 
					esp->seq_num = endian32(++current_sa->seq_counter);
					// TODO : Seq# overflow check
					
					// 6. ICV Calculation
					if(current_sa->iv_mode == true)
					{
						size = endian16(packet->length) - (packet->ihl * 4) - ICV_LEN; 
						unsigned char* result;
						
						current_sa->auth->authenticate(packet, size, result);
							
						memcpy(&(packet->body[len - size], result, 12)); 	
					}
					break;
				case IP_PROTOCOL_AH :
					break;
				default : 
					break;
			}
			break;
		case TUNNEL :
			switch(current_sp->protocol)
			{
				case IP_PROTOCOL_ESP :
					// 3. Inner IP Making
					// 4. Encrypt
					current_sa->crypto->cryptograph(packet, packet_len);
					// 5. ESP Header & Trailer Addition
					// 6. Seq# Validation
					// 7. ICV Calculation
					break;
				case IP_PROTOCOL_AH :
					break;
				default : 
					break;
			}
			break;
		default : 
			break;
	}
	
	
	return 0;
}

